Part 1: Buffer Overflows -- The Webserver

	FrobozzCo has a longstanding tradition of reinventing the wheel whenever possible. As the old saying goes, "Why use something great that someone else made when you can use a mediocre thing you made yourself?" Additionally, the prevailing belief in management is that in-house software is more secure than third-party software since FrobozzCo alone has access to the sourcecode. To that end, when the Great Web Revolution hit and statistics relating to frobnick production were needed by remote facilities, the higher-ups at FrobozzCo insisted that their engineers write a webserver daemon, and it has been dutifully (if unspectacularly) serving web pages for many years.

	Unfortunately, it is clear that someone has "rooted" (i.e., gained unauthorized superuser access to) the server; a number of root access files were copied out over the Internet and then the server started sending tons of spam. Fortunately, no data was lost, but the intruder had full control of the server and it is still unknown how they got in. You are convinced there is an exploitable buffer overflow bug in the web server software, but your boss, William H. Flathead III laughed off your suspicions saying, "I wrote the web server software -- and I'd never have made that mistake!"

	Nevertheless, he suggests you investigate the possibility of a buffer overflow, "just to be sure."

	He asks you to produce a one page memo with an attached working demo that targets a specific buffer overflow (should one exist) causing the server to crash. This should be an intentionally exploitable hole in the code and not simply a robustness issue. If you find a vulnerability, your boss wants a patch to fix it. Finally, he wants to know how to clean up this mess -- how severe is this specific compromise? How can we restore the system to a safe state?


	Buffer Overflow Tasks

	Load your Exploits experiment in DETER.
	Find the buffer overflow in the fhttpd webserver code.
	The sourcecode is in the directory /usr/src/fhttpd.
	Exploit the overflow, causing the software to crash.
	Please note: you may be able to crash the software in other ways -- we are only specifically interested in a buffer overflow caused by input that is not properly bound-checked.
	See RFC 1945, which covers the HTTP protocol. In this document, you can learn about what the HTTP API looks like and how to send commands to web servers manually.
	Create an executable program (script or binary with sourcecode), demonstrating your exploit. We've created a skeleton exploit in /root/exploit1.sh and /root/payload1. Edit these with a text editor.
	Fix the buffer overflow bug in the fhttpd sourcecode and create a patch against the original.
	To compile the code:
	cd /usr/src/fhttpd
	sudo make
	To install and run the code:
	sudo make install (this copies in your new binary and restarts the default server on port 8080)
	See the tools section of this document for instructions on diff,patch, and other utilities.
	See also the section on restarting servers.
	Write a ~1 page memo:
	Describe the security flaw you found, how you fixed it, and how your demo exploit works. (The memo itself should quote as little sourcecode as possible; for longer sections, refer to filenames and line numbers in the original or your attached patch.)
	Considering fhttpd alone, include in your memo:
	An evaluation of the seriousness of the breach
	A recovery plan for the server. (Is it enough to fix the flaw? Why or why not?)
	Any other observations or thoughts you might have.
	Put the following files into in /root/part1:
	your memo
	your working demo with instructions
	your patch
	Use the scripts described in the section for creating a submission tarball.

	I wasn't able to get this working. I will be documenting what I have been able to do related to this task.

	To start the webserver, I tunnel into my Putty Configuration "Deterlab-tunnel"

	The hostname for this tunnel is "nv8476am@users.deterlab.net"
	The Port is "22"
	The SSH Tunnel is "L8118	server.nv8476am-exploits.ece8476.isi.deterlab.net:80"

	After logging in, ssh into the correct computer session set up in deterlab, then start the webserver

		sudo su -
		apt-get install gdb
		cd /./usr/src/fhttpd/server
		gdb webserver
		run 8118
		
	Open another putty window and run

		sudo su -
		cd /./users/nv8476am/exploits/part1

	I ran into a problem when I tried to send a payload.

	The assignment called to send payload1 with exploit1.sh

	L8118	server.nv8476am-exploits.ece8476.isi.deterlab.net:80

	After delivering a payload full of characters ("x" over 1024 times), I got a segmentation fault:
	
	Program received signal SIGSEGV, Segmentation fault.
	[Switching to Thread 0xb7ff4b70 (LWP 3841)]
	0x08049507 in send_response (sockfd=6, req=0xb7ff4340, statcode=200)
		at server/webserver.c:219
	219       if (req->uri == NULL || req->method == NULL ||

	After getting a segmentation fault, the server must be restarted with "run 8118" again.
	
	The line that was in error was:
	
	if (req->uri == NULL || req->method == NULL ||
		req->headers == NULL || req->version == NULL) {
		return 0;
	}

	I altered the function to be 

	if (req->uri == NULL) {
	  return 0;
	} 
	if (req->method == NULL) {
	  return 0;
	} 
	if (req->headers == NULL) {
	  return 0;
	} 

	if (req->version == NULL) {
	  return 0;
	}
	
	This fixed the segmentation fault.
	
	While I originally tried this just to identify which part of the http response was in error, it ended up fixing the problem. This means that the call to one of the later parts of the header would be in error, but the a NULL test stops that part of being in error.
	
	This means one of 6 conditions:
	
		req->uri == NULL and req->method produces a segmentation fault
		req->uri == NULL and req->headers produces a segmentation fault
		req->uri == NULL and req->version produces a segmentation fault
		req->method == NULL and req->headers produces a segmentation fault
		req->method == NULL and req->version produces a segmentation fault
		req->headers == NULL and req->version produces a segmentation fault

	This fixed the segmentation fault, but switching the commands around did not re-break the system, which doesn't make any sense.
	
	This implies that the segmentation fault does not happen consistently, which generates an entirely new problem as the input did not change.
	
	Based on the contents of webserver.c, there are 2 possible places where a 1024 character limit is set.
	
	In send_response, if the req->uri is greater than 1024 characters and the statcode = 200, then there will be an overflow when the "path" is added to the sendmessage variable with strcat. To remedy this, I would add a test on the strcat commands used in send_response to make sure the resulting string does not exceed 1024 characters. It can be noted that since other stuff is added to this string, we may need less than 1024 characters, but the other strings aren't nearly as long.
	
	In get_header, we have a similar problem if req->headers exceeds 1024 characters and the searchstr appears inside req->headers and exceeds 1024 characters
	

	
	::Run on cmd.exe to copy part 1 to local directory
	"C:\Program Files (x86)\Putty\pscp.exe" "nv8476am@users.deterlab.net:/users/nv8476am/exploits/part1/*" "C:\Users\thoma_000\Documents\Grad School\Cryptography\Lab 2\part1"
	::Run on cmd.exe to copy part 1 from local directory
	"C:\Program Files (x86)\Putty\pscp.exe" "C:\Users\thoma_000\Documents\Grad School\Cryptography\Lab 2\part1\*" "nv8476am@users.deterlab.net:/users/nv8476am/exploits/part1"
	 
	